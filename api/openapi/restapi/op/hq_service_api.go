// Code generated by go-swagger; DO NOT EDIT.

package op

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/runtime/security"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// NewHqServiceAPI creates a new HqService instance
func NewHqServiceAPI(spec *loads.Document) *HqServiceAPI {
	return &HqServiceAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		customConsumers:     make(map[string]runtime.Consumer),
		customProducers:     make(map[string]runtime.Producer),
		PreServerShutdown:   func() {},
		ServerShutdown:      func() {},
		spec:                spec,
		useSwaggerUI:        false,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,

		JSONConsumer:    runtime.JSONConsumer(),
		UrlformConsumer: runtime.DiscardConsumer,

		JSONProducer: runtime.JSONProducer(),

		CreateUserHandler: CreateUserHandlerFunc(func(params CreateUserParams) middleware.Responder {
			return middleware.NotImplemented("operation CreateUser has not yet been implemented")
		}),
		GetAccessTokenHandler: GetAccessTokenHandlerFunc(func(params GetAccessTokenParams) middleware.Responder {
			return middleware.NotImplemented("operation GetAccessToken has not yet been implemented")
		}),
		GetAccountsHandler: GetAccountsHandlerFunc(func(params GetAccountsParams) middleware.Responder {
			return middleware.NotImplemented("operation GetAccounts has not yet been implemented")
		}),
		GetAuthAccountHandler: GetAuthAccountHandlerFunc(func(params GetAuthAccountParams) middleware.Responder {
			return middleware.NotImplemented("operation GetAuthAccount has not yet been implemented")
		}),
		GetBalanceHandler: GetBalanceHandlerFunc(func(params GetBalanceParams) middleware.Responder {
			return middleware.NotImplemented("operation GetBalance has not yet been implemented")
		}),
		GetIdentityHandler: GetIdentityHandlerFunc(func(params GetIdentityParams) middleware.Responder {
			return middleware.NotImplemented("operation GetIdentity has not yet been implemented")
		}),
		GetInfoHandler: GetInfoHandlerFunc(func(params GetInfoParams) middleware.Responder {
			return middleware.NotImplemented("operation GetInfo has not yet been implemented")
		}),
		GetSandboxAccessTokenHandler: GetSandboxAccessTokenHandlerFunc(func(params GetSandboxAccessTokenParams) middleware.Responder {
			return middleware.NotImplemented("operation GetSandboxAccessToken has not yet been implemented")
		}),
		GetTransactionsHandler: GetTransactionsHandlerFunc(func(params GetTransactionsParams) middleware.Responder {
			return middleware.NotImplemented("operation GetTransactions has not yet been implemented")
		}),
		GetUserByIDHandler: GetUserByIDHandlerFunc(func(params GetUserByIDParams) middleware.Responder {
			return middleware.NotImplemented("operation GetUserByID has not yet been implemented")
		}),
		GetUsersHandler: GetUsersHandlerFunc(func(params GetUsersParams) middleware.Responder {
			return middleware.NotImplemented("operation GetUsers has not yet been implemented")
		}),
		LinkTokenCreateHandler: LinkTokenCreateHandlerFunc(func(params LinkTokenCreateParams) middleware.Responder {
			return middleware.NotImplemented("operation LinkTokenCreate has not yet been implemented")
		}),
		UpdateUserHandler: UpdateUserHandlerFunc(func(params UpdateUserParams) middleware.Responder {
			return middleware.NotImplemented("operation UpdateUser has not yet been implemented")
		}),
		HealthCheckHandler: HealthCheckHandlerFunc(func(params HealthCheckParams) middleware.Responder {
			return middleware.NotImplemented("operation HealthCheck has not yet been implemented")
		}),
	}
}

/*
HqServiceAPI # ...
## List of all custom errors
First number is HTTP Status code, second is value of "code" field in returned JSON object, text description may or may not match "message" field in returned JSON object.
*/
type HqServiceAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler
	useSwaggerUI    bool

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator

	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator

	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for the following mime types:
	//   - application/json
	JSONConsumer runtime.Consumer
	// UrlformConsumer registers a consumer for the following mime types:
	//   - application/x-www-form-urlencoded
	UrlformConsumer runtime.Consumer

	// JSONProducer registers a producer for the following mime types:
	//   - application/json
	JSONProducer runtime.Producer

	// CreateUserHandler sets the operation handler for the create user operation
	CreateUserHandler CreateUserHandler
	// GetAccessTokenHandler sets the operation handler for the get access token operation
	GetAccessTokenHandler GetAccessTokenHandler
	// GetAccountsHandler sets the operation handler for the get accounts operation
	GetAccountsHandler GetAccountsHandler
	// GetAuthAccountHandler sets the operation handler for the get auth account operation
	GetAuthAccountHandler GetAuthAccountHandler
	// GetBalanceHandler sets the operation handler for the get balance operation
	GetBalanceHandler GetBalanceHandler
	// GetIdentityHandler sets the operation handler for the get identity operation
	GetIdentityHandler GetIdentityHandler
	// GetInfoHandler sets the operation handler for the get info operation
	GetInfoHandler GetInfoHandler
	// GetSandboxAccessTokenHandler sets the operation handler for the get sandbox access token operation
	GetSandboxAccessTokenHandler GetSandboxAccessTokenHandler
	// GetTransactionsHandler sets the operation handler for the get transactions operation
	GetTransactionsHandler GetTransactionsHandler
	// GetUserByIDHandler sets the operation handler for the get user by ID operation
	GetUserByIDHandler GetUserByIDHandler
	// GetUsersHandler sets the operation handler for the get users operation
	GetUsersHandler GetUsersHandler
	// LinkTokenCreateHandler sets the operation handler for the link token create operation
	LinkTokenCreateHandler LinkTokenCreateHandler
	// UpdateUserHandler sets the operation handler for the update user operation
	UpdateUserHandler UpdateUserHandler
	// HealthCheckHandler sets the operation handler for the health check operation
	HealthCheckHandler HealthCheckHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// PreServerShutdown is called before the HTTP(S) server is shutdown
	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
	PreServerShutdown func()

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// UseRedoc for documentation at /docs
func (o *HqServiceAPI) UseRedoc() {
	o.useSwaggerUI = false
}

// UseSwaggerUI for documentation at /docs
func (o *HqServiceAPI) UseSwaggerUI() {
	o.useSwaggerUI = true
}

// SetDefaultProduces sets the default produces media type
func (o *HqServiceAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *HqServiceAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *HqServiceAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *HqServiceAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *HqServiceAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *HqServiceAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *HqServiceAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the HqServiceAPI
func (o *HqServiceAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}
	if o.UrlformConsumer == nil {
		unregistered = append(unregistered, "UrlformConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.CreateUserHandler == nil {
		unregistered = append(unregistered, "CreateUserHandler")
	}
	if o.GetAccessTokenHandler == nil {
		unregistered = append(unregistered, "GetAccessTokenHandler")
	}
	if o.GetAccountsHandler == nil {
		unregistered = append(unregistered, "GetAccountsHandler")
	}
	if o.GetAuthAccountHandler == nil {
		unregistered = append(unregistered, "GetAuthAccountHandler")
	}
	if o.GetBalanceHandler == nil {
		unregistered = append(unregistered, "GetBalanceHandler")
	}
	if o.GetIdentityHandler == nil {
		unregistered = append(unregistered, "GetIdentityHandler")
	}
	if o.GetInfoHandler == nil {
		unregistered = append(unregistered, "GetInfoHandler")
	}
	if o.GetSandboxAccessTokenHandler == nil {
		unregistered = append(unregistered, "GetSandboxAccessTokenHandler")
	}
	if o.GetTransactionsHandler == nil {
		unregistered = append(unregistered, "GetTransactionsHandler")
	}
	if o.GetUserByIDHandler == nil {
		unregistered = append(unregistered, "GetUserByIDHandler")
	}
	if o.GetUsersHandler == nil {
		unregistered = append(unregistered, "GetUsersHandler")
	}
	if o.LinkTokenCreateHandler == nil {
		unregistered = append(unregistered, "LinkTokenCreateHandler")
	}
	if o.UpdateUserHandler == nil {
		unregistered = append(unregistered, "UpdateUserHandler")
	}
	if o.HealthCheckHandler == nil {
		unregistered = append(unregistered, "HealthCheckHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *HqServiceAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *HqServiceAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
	return nil
}

// Authorizer returns the registered authorizer
func (o *HqServiceAPI) Authorizer() runtime.Authorizer {
	return nil
}

// ConsumersFor gets the consumers for the specified media types.
// MIME type parameters are ignored here.
func (o *HqServiceAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
	result := make(map[string]runtime.Consumer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONConsumer
		case "application/x-www-form-urlencoded":
			result["application/x-www-form-urlencoded"] = o.UrlformConsumer
		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result
}

// ProducersFor gets the producers for the specified media types.
// MIME type parameters are ignored here.
func (o *HqServiceAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
	result := make(map[string]runtime.Producer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONProducer
		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result
}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *HqServiceAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the hq service API
func (o *HqServiceAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *HqServiceAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened
	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/user"] = NewCreateUser(o.context, o.CreateUserHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set_access_token"] = NewGetAccessToken(o.context, o.GetAccessTokenHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/accounts"] = NewGetAccounts(o.context, o.GetAccountsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/auth"] = NewGetAuthAccount(o.context, o.GetAuthAccountHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/balance"] = NewGetBalance(o.context, o.GetBalanceHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/identity"] = NewGetIdentity(o.context, o.GetIdentityHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/info"] = NewGetInfo(o.context, o.GetInfoHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/sandbox_access_token/{institution_id}"] = NewGetSandboxAccessToken(o.context, o.GetSandboxAccessTokenHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/transactions"] = NewGetTransactions(o.context, o.GetTransactionsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/user/{user_id}"] = NewGetUserByID(o.context, o.GetUserByIDHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/users"] = NewGetUsers(o.context, o.GetUsersHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/create_link_token"] = NewLinkTokenCreate(o.context, o.LinkTokenCreateHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/user"] = NewUpdateUser(o.context, o.UpdateUserHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/health-check"] = NewHealthCheck(o.context, o.HealthCheckHandler)
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *HqServiceAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	if o.useSwaggerUI {
		return o.context.APIHandlerSwaggerUI(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *HqServiceAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *HqServiceAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *HqServiceAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// AddMiddlewareFor adds a http middleware to existing handler
func (o *HqServiceAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
	um := strings.ToUpper(method)
	if path == "/" {
		path = ""
	}
	o.Init()
	if h, ok := o.handlers[um][path]; ok {
		o.handlers[method][path] = builder(h)
	}
}
