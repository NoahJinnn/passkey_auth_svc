// Code generated by go-swagger; DO NOT EDIT.

package model

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Transaction Transaction
//
// swagger:model Transaction
type Transaction struct {

	// account id
	// Required: true
	AccountID *string `json:"account_id"`

	// account owner
	// Required: true
	AccountOwner *NullableString `json:"account_owner"`

	// amount
	// Required: true
	Amount *float64 `json:"amount"`

	// authorized date
	// Required: true
	AuthorizedDate *NullableString `json:"authorized_date"`

	// authorized datetime
	// Required: true
	AuthorizedDatetime *NullableTime `json:"authorized_datetime"`

	// category
	// Required: true
	Category []string `json:"category"`

	// category id
	// Required: true
	CategoryID *NullableString `json:"category_id"`

	// check number
	// Required: true
	CheckNumber *NullableString `json:"check_number"`

	// date
	// Required: true
	Date *string `json:"date"`

	// datetime
	// Required: true
	Datetime *NullableTime `json:"datetime"`

	// iso currency code
	// Required: true
	IsoCurrencyCode *NullableString `json:"iso_currency_code"`

	// location
	// Required: true
	Location *Location `json:"location"`

	// merchant name
	// Required: true
	MerchantName *NullableString `json:"merchant_name"`

	// name
	// Required: true
	Name *string `json:"name"`

	// original description
	// Required: true
	OriginalDescription *NullableString `json:"original_description"`

	// payment channel
	// Required: true
	PaymentChannel *string `json:"payment_channel"`

	// payment meta
	// Required: true
	PaymentMeta *PaymentMeta `json:"payment_meta"`

	// pending
	// Required: true
	Pending bool `json:"pending"`

	// pending transaction id
	// Required: true
	PendingTransactionID *NullableString `json:"pending_transaction_id"`

	// personal finance category
	// Required: true
	PersonalFinanceCategory *NullablePersonalFinanceCategory `json:"personal_finance_category"`

	// transaction code
	// Required: true
	TransactionCode *NullableTransactionCode `json:"transaction_code"`

	// transaction id
	// Required: true
	TransactionID *string `json:"transaction_id"`

	// transaction type
	// Required: true
	TransactionType *string `json:"transaction_type"`

	// unofficial currency code
	// Required: true
	UnofficialCurrencyCode *NullableString `json:"unofficial_currency_code"`
}

// UnmarshalJSON unmarshals this object while disallowing additional properties from JSON
func (m *Transaction) UnmarshalJSON(data []byte) error {
	var props struct {

		// account id
		// Required: true
		AccountID *string `json:"account_id"`

		// account owner
		// Required: true
		AccountOwner *NullableString `json:"account_owner"`

		// amount
		// Required: true
		Amount *float64 `json:"amount"`

		// authorized date
		// Required: true
		AuthorizedDate *NullableString `json:"authorized_date"`

		// authorized datetime
		// Required: true
		AuthorizedDatetime *NullableTime `json:"authorized_datetime"`

		// category
		// Required: true
		Category []string `json:"category"`

		// category id
		// Required: true
		CategoryID *NullableString `json:"category_id"`

		// check number
		// Required: true
		CheckNumber *NullableString `json:"check_number"`

		// date
		// Required: true
		Date *string `json:"date"`

		// datetime
		// Required: true
		Datetime *NullableTime `json:"datetime"`

		// iso currency code
		// Required: true
		IsoCurrencyCode *NullableString `json:"iso_currency_code"`

		// location
		// Required: true
		Location *Location `json:"location"`

		// merchant name
		// Required: true
		MerchantName *NullableString `json:"merchant_name"`

		// name
		// Required: true
		Name *string `json:"name"`

		// original description
		// Required: true
		OriginalDescription *NullableString `json:"original_description"`

		// payment channel
		// Required: true
		PaymentChannel *string `json:"payment_channel"`

		// payment meta
		// Required: true
		PaymentMeta *PaymentMeta `json:"payment_meta"`

		// pending
		// Required: true
		Pending bool `json:"pending"`

		// pending transaction id
		// Required: true
		PendingTransactionID *NullableString `json:"pending_transaction_id"`

		// personal finance category
		// Required: true
		PersonalFinanceCategory *NullablePersonalFinanceCategory `json:"personal_finance_category"`

		// transaction code
		// Required: true
		TransactionCode *NullableTransactionCode `json:"transaction_code"`

		// transaction id
		// Required: true
		TransactionID *string `json:"transaction_id"`

		// transaction type
		// Required: true
		TransactionType *string `json:"transaction_type"`

		// unofficial currency code
		// Required: true
		UnofficialCurrencyCode *NullableString `json:"unofficial_currency_code"`
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.DisallowUnknownFields()
	if err := dec.Decode(&props); err != nil {
		return err
	}

	m.AccountID = props.AccountID
	m.AccountOwner = props.AccountOwner
	m.Amount = props.Amount
	m.AuthorizedDate = props.AuthorizedDate
	m.AuthorizedDatetime = props.AuthorizedDatetime
	m.Category = props.Category
	m.CategoryID = props.CategoryID
	m.CheckNumber = props.CheckNumber
	m.Date = props.Date
	m.Datetime = props.Datetime
	m.IsoCurrencyCode = props.IsoCurrencyCode
	m.Location = props.Location
	m.MerchantName = props.MerchantName
	m.Name = props.Name
	m.OriginalDescription = props.OriginalDescription
	m.PaymentChannel = props.PaymentChannel
	m.PaymentMeta = props.PaymentMeta
	m.Pending = props.Pending
	m.PendingTransactionID = props.PendingTransactionID
	m.PersonalFinanceCategory = props.PersonalFinanceCategory
	m.TransactionCode = props.TransactionCode
	m.TransactionID = props.TransactionID
	m.TransactionType = props.TransactionType
	m.UnofficialCurrencyCode = props.UnofficialCurrencyCode
	return nil
}

// Validate validates this transaction
func (m *Transaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizedDatetime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategoryID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatetime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsoCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchantName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePending(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePendingTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePersonalFinanceCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnofficialCurrencyCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Transaction) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("account_id", "body", m.AccountID); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateAccountOwner(formats strfmt.Registry) error {

	if err := validate.Required("account_owner", "body", m.AccountOwner); err != nil {
		return err
	}

	if m.AccountOwner != nil {
		if err := m.AccountOwner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_owner")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateAuthorizedDate(formats strfmt.Registry) error {

	if err := validate.Required("authorized_date", "body", m.AuthorizedDate); err != nil {
		return err
	}

	if m.AuthorizedDate != nil {
		if err := m.AuthorizedDate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorized_date")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorized_date")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateAuthorizedDatetime(formats strfmt.Registry) error {

	if err := validate.Required("authorized_datetime", "body", m.AuthorizedDatetime); err != nil {
		return err
	}

	if m.AuthorizedDatetime != nil {
		if err := m.AuthorizedDatetime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorized_datetime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorized_datetime")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateCategory(formats strfmt.Registry) error {

	if err := validate.Required("category", "body", m.Category); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateCategoryID(formats strfmt.Registry) error {

	if err := validate.Required("category_id", "body", m.CategoryID); err != nil {
		return err
	}

	if m.CategoryID != nil {
		if err := m.CategoryID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("category_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("category_id")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateCheckNumber(formats strfmt.Registry) error {

	if err := validate.Required("check_number", "body", m.CheckNumber); err != nil {
		return err
	}

	if m.CheckNumber != nil {
		if err := m.CheckNumber.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("check_number")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("check_number")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateDate(formats strfmt.Registry) error {

	if err := validate.Required("date", "body", m.Date); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateDatetime(formats strfmt.Registry) error {

	if err := validate.Required("datetime", "body", m.Datetime); err != nil {
		return err
	}

	if m.Datetime != nil {
		if err := m.Datetime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datetime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datetime")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateIsoCurrencyCode(formats strfmt.Registry) error {

	if err := validate.Required("iso_currency_code", "body", m.IsoCurrencyCode); err != nil {
		return err
	}

	if m.IsoCurrencyCode != nil {
		if err := m.IsoCurrencyCode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iso_currency_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iso_currency_code")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateLocation(formats strfmt.Registry) error {

	if err := validate.Required("location", "body", m.Location); err != nil {
		return err
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateMerchantName(formats strfmt.Registry) error {

	if err := validate.Required("merchant_name", "body", m.MerchantName); err != nil {
		return err
	}

	if m.MerchantName != nil {
		if err := m.MerchantName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchant_name")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchant_name")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateOriginalDescription(formats strfmt.Registry) error {

	if err := validate.Required("original_description", "body", m.OriginalDescription); err != nil {
		return err
	}

	if m.OriginalDescription != nil {
		if err := m.OriginalDescription.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("original_description")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("original_description")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validatePaymentChannel(formats strfmt.Registry) error {

	if err := validate.Required("payment_channel", "body", m.PaymentChannel); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validatePaymentMeta(formats strfmt.Registry) error {

	if err := validate.Required("payment_meta", "body", m.PaymentMeta); err != nil {
		return err
	}

	if m.PaymentMeta != nil {
		if err := m.PaymentMeta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payment_meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payment_meta")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validatePending(formats strfmt.Registry) error {

	if err := validate.Required("pending", "body", bool(m.Pending)); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validatePendingTransactionID(formats strfmt.Registry) error {

	if err := validate.Required("pending_transaction_id", "body", m.PendingTransactionID); err != nil {
		return err
	}

	if m.PendingTransactionID != nil {
		if err := m.PendingTransactionID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pending_transaction_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pending_transaction_id")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validatePersonalFinanceCategory(formats strfmt.Registry) error {

	if err := validate.Required("personal_finance_category", "body", m.PersonalFinanceCategory); err != nil {
		return err
	}

	if m.PersonalFinanceCategory != nil {
		if err := m.PersonalFinanceCategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("personal_finance_category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("personal_finance_category")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateTransactionCode(formats strfmt.Registry) error {

	if err := validate.Required("transaction_code", "body", m.TransactionCode); err != nil {
		return err
	}

	if m.TransactionCode != nil {
		if err := m.TransactionCode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transaction_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transaction_code")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) validateTransactionID(formats strfmt.Registry) error {

	if err := validate.Required("transaction_id", "body", m.TransactionID); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateTransactionType(formats strfmt.Registry) error {

	if err := validate.Required("transaction_type", "body", m.TransactionType); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateUnofficialCurrencyCode(formats strfmt.Registry) error {

	if err := validate.Required("unofficial_currency_code", "body", m.UnofficialCurrencyCode); err != nil {
		return err
	}

	if m.UnofficialCurrencyCode != nil {
		if err := m.UnofficialCurrencyCode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unofficial_currency_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("unofficial_currency_code")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this transaction based on the context it is used
func (m *Transaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccountOwner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthorizedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthorizedDatetime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCategoryID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCheckNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatetime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsoCurrencyCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMerchantName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginalDescription(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePendingTransactionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePersonalFinanceCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransactionCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnofficialCurrencyCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Transaction) contextValidateAccountOwner(ctx context.Context, formats strfmt.Registry) error {

	if m.AccountOwner != nil {
		if err := m.AccountOwner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_owner")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateAuthorizedDate(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthorizedDate != nil {
		if err := m.AuthorizedDate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorized_date")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorized_date")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateAuthorizedDatetime(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthorizedDatetime != nil {
		if err := m.AuthorizedDatetime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorized_datetime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authorized_datetime")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateCategoryID(ctx context.Context, formats strfmt.Registry) error {

	if m.CategoryID != nil {
		if err := m.CategoryID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("category_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("category_id")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateCheckNumber(ctx context.Context, formats strfmt.Registry) error {

	if m.CheckNumber != nil {
		if err := m.CheckNumber.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("check_number")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("check_number")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateDatetime(ctx context.Context, formats strfmt.Registry) error {

	if m.Datetime != nil {
		if err := m.Datetime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datetime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datetime")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateIsoCurrencyCode(ctx context.Context, formats strfmt.Registry) error {

	if m.IsoCurrencyCode != nil {
		if err := m.IsoCurrencyCode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iso_currency_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iso_currency_code")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateMerchantName(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantName != nil {
		if err := m.MerchantName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchant_name")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchant_name")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateOriginalDescription(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginalDescription != nil {
		if err := m.OriginalDescription.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("original_description")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("original_description")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidatePaymentMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.PaymentMeta != nil {
		if err := m.PaymentMeta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payment_meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payment_meta")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidatePendingTransactionID(ctx context.Context, formats strfmt.Registry) error {

	if m.PendingTransactionID != nil {
		if err := m.PendingTransactionID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pending_transaction_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pending_transaction_id")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidatePersonalFinanceCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.PersonalFinanceCategory != nil {
		if err := m.PersonalFinanceCategory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("personal_finance_category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("personal_finance_category")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateTransactionCode(ctx context.Context, formats strfmt.Registry) error {

	if m.TransactionCode != nil {
		if err := m.TransactionCode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transaction_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transaction_code")
			}
			return err
		}
	}

	return nil
}

func (m *Transaction) contextValidateUnofficialCurrencyCode(ctx context.Context, formats strfmt.Registry) error {

	if m.UnofficialCurrencyCode != nil {
		if err := m.UnofficialCurrencyCode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unofficial_currency_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("unofficial_currency_code")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Transaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Transaction) UnmarshalBinary(b []byte) error {
	var res Transaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
